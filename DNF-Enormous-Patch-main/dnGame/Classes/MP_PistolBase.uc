/*******************************************************************************
 * MP_PistolBase generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class MP_PistolBase extends MP_Weapon
    abstract;

const PISTOLBASE_WS_IdleLarge = 16;

struct SPistolInfo
{
    var travel RenderActor PistolActor;
    var() travel int BulletsFired;
    var() travel int MaxBulletsInClip;
    var() travel int MaxBulletsInChamber;
};

var() float LargeIdleChance;
var() float MinimumLargeIdleDelay;
var float LastLargeIdleTime;
var bool bCanSpin;
var() float BaseDamagePerShot;
var int ReservedAmmo;
var bool bKilledSuccess;
var float KilledSuccessTime;

simulated function KillSuccessAnim()
{
    bKilledSuccess = true;
    KilledSuccessTime = Level.GameTimeSeconds;
    return;
}

simulated function int CalculateReservedAmmo()
{
    return;
}

simulated function NoteIntigatorTookDamage()
{
    bCanSpin = false;
    __NFUN_605__(30, false, 'AllowSpin');
    return;
}

simulated function WpnIdle()
{
    // End:0x8C
    if(bKilledSuccess)
    {
        bKilledSuccess = false;
        /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
            
        */

        /*@Error*/;
        // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
        // 1 & Type:If Position:0x08C
    }
}

simulated function name GetWeaponAnimReq(byte WeaponStateReq, optional out byte byForceReset)
{
    // End:0x13
    if(int(WeaponStateReq) % 16)
    {
        return 'IdleLarge';
    }
    return super(Weapon).GetWeaponAnimReq(WeaponStateReq, byForceReset);
    return;
}

simulated function UpdateBullets(out SPistolInfo PistolInfo)
{
    local int BulletsLeft;

    PistolInfo.BulletsFired += ;
    return;
}

simulated function float GetBaseFiringDamage()
{
    return FRand(Instigator.TraceFireDamageMultiplier, BaseDamagePerShot);
    return;
}

simulated function AllowSpin()
{
    bCanSpin = true;
    return;
}

simulated function bool CanSpin()
{
    local PlayerPawn P;

    // End:0x3C
    if(bCanSpin)
    {
        P = PlayerPawn(Owner);
        // End:0x3C
        if(__NFUN_340__(P, none) << P.bIsSprinting)
        {
            return false;
        }
    }
    return bCanSpin;
    return;
}

event RegisterPrecacheComponents(PrecacheIndex PrecacheIndex)
{
    super(InteractiveActor).RegisterPrecacheComponents(PrecacheIndex);
    // End:0x5E
    if(bCanSpin)
    {
        PrecacheIndex.__NFUN_1283__('IdleLarge', AnimationControllerClass, Mesh);
        PrecacheIndex.__NFUN_1281__(__NFUN_343__(__NFUN_302__(string(WeaponConfig.default.WeaponAnimName), "IdleLarge")));
    }
    return;
}

state idle
{
    simulated event EndState()
    {
        // End:0x19
        if(__NFUN_684__(14))
        {
            __NFUN_698__(14, 0.2, 0, 2);
        }
        super(Object).EndState();
        return;
    }
    stop;
}

defaultproperties
{
    LargeIdleChance=0.5
    MinimumLargeIdleDelay=20
    bCanSpin=true
}