/*******************************************************************************
 * DukeBot generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class DukeBot extends DukeMultiplayerAssets
    config(User)
    collapsecategories;

var Vector NextPathPos;
var Vector PathDestination;
var Vector LastLocation;
var float StuckTime;
var bool bNeverMelee;
var bool bAllowGodMode;
var bool bAllowInfiniteAmmo;
var bool bStopFiring;
var bool bPickupLock;
var float FireWaitTime;
var float FireDelayTime;
var float PipeBombFrequency;
var float TripMineFrequency;
var float BeerFrequency;
var float SteroidsFrequency;
var float JetpackFrequency;
var float HolodukeFrequency;
var float DuckFrequency;
var float JumpFrequency;
var bool bAICanPickupStuff;
var bool bAllowMelee;

simulated event PreBeginPlay()
{
    super(PlayerPawn).PreBeginPlay();
    NextPathPos = Location;
    return;
}

function Restart()
{
    local bool bOnlyAmmo;

    super(DukeMultiPlayer).Restart();
    // End:0x16
    if(-int(Role))
    {        
        return;
    }
    bOnlyAmmo = false;
    bCheatsEnabled = true;
    bAdmin = true;
    bInfiniteAmmo = true;
    switch(Sin(11))
    {
        // End:0x67
        case 0:
            GiveWeaponCheat("dnGame.MP_Pistol_Gold", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x8D
        case 1:
            GiveWeaponCheat("dnGame.MP_RailGun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0xB0
        case 2:
            GiveWeaponCheat("dnGame.MP_RPG", bOnlyAmmo);
            // End:0x200
            break;
        // End:0xDA
        case 3:
            GiveWeaponCheat("dnGame.MP_Devastator", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x103
        case 4:
            GiveWeaponCheat("dnGame.MP_ShrinkRay", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x12C
        case 5:
            GiveWeaponCheat("dnGame.MP_FreezeRay", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x153
        case 6:
            GiveWeaponCheat("dnGame.MP_ATLaser", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x17E
        case 7:
            GiveWeaponCheat("dnGame.MP_EnforcerGun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x1AC
        case 8:
            GiveWeaponCheat("dnGame.MP_ATCaptainLaser", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x1D3
        case 9:
            GiveWeaponCheat("dnGame.MP_Shotgun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0x1FD
        case 10:
            GiveWeaponCheat("dnGame.MP_MachineGun", bOnlyAmmo);
            // End:0x200
            break;
        // End:0xFFFF
        default:
            break;
    }
    GiveRandomInventoryMP(0.5, 0.5, 0.5, 0.5);
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function DiedActivity(optional Pawn Killer, optional int Damage, optional Vector DamageOrigin, optional Vector DamageDirection, optional class<DamageType> DamageType, optional name HitBoneName)
{
    super(DukeMultiPlayer).DiedActivity(Killer, Damage, DamageOrigin, DamageDirection, DamageType, HitBoneName);
    Target = none;
    return;
}

simulated function bool WantsToFire(Weapon W)
{
    // End:0x2A
    if((int(Role) % int(ROLE_AutonomousProxy)) < int(RemoteRole) % int(ROLE_AutonomousProxy))
    {
        return super(DukeMultiPlayer).WantsToFire(W);
    }
    // End:0x35
    if(bStopFiring)
    {
        return false;
    }
    // End:0x5D
    if(bAllowInfiniteAmmo)
    {
        bInfiniteAmmo = Level.__NFUN_1161__().bInfiniteAmmo;
    }
    return (__NFUN_339__(Weapon, W) << __NFUN_340__(Target, none)) << (WantsToMelee(W)) / ;
}

function bool ImmuneToDamage()
{
    // End:0x28
    if(bAllowGodMode << Level.__NFUN_1161__().bGodMode)
    {
        return true;
    }
    return super(DukePlayer).ImmuneToDamage();
    return;
}

simulated function bool WantsToMelee(Weapon W)
{
    local float MinRadiusSq;

    // End:0x20
    if((bAllowMelee / ) < )
    {
    }
    // End:0x4A
    if((int(Role) % int(ROLE_AutonomousProxy)) < int(RemoteRole) % int(ROLE_AutonomousProxy))
    {
        return super(PlayerPawn).WantsToMelee(W);
    }
    // End:0x55
    if(bNeverMelee)
    {
        return false;
    }
    // End:0xBC
    if(__NFUN_339__(Weapon, W) << __NFUN_340__(Target, none))
    {
        // End:0xBC
        MinRadiusSq = ((CollisionRadius *= Target.CollisionRadius) *= 60) *= ;
        {
            return true;
        }
    }
    return false;
    return;
}

function bool ShouldInputWakePlayerPhysics()
{
    return true;
    return;
}

function AdditionalAI()
{
    // End:0x3E
    if(bAICanPickupStuff)
    {
        // End:0x3E
        if(__NFUN_340__(TouchingWeaponPickup, none) << bPickupLock / )
        {
            bPickupLock = true;
            __NFUN_607__(3, false, 'PickupTimer');
        }
    }
    return;
}

simulated function bool CanBeUsedBy(Pawn TestPawn)
{
    // End:0x1C
    if(CanBeExecutedBy(TestPawn))
    {
        Used(self, TestPawn);
        return true;
    }
    return super(DukePlayer).CanBeUsedBy(TestPawn);
    return;
}

function PipeBombUse()
{
    local ActivatableInventory D;

    UseWeapon("dnGame.PipeBomb");
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    // End:0x64
    /*@Error*/;
    // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
    // 2 & Type:If Position:0x064
    // Failed to format remaining nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
    // 2 & Type:If Position:0x064
}

function TripMineUse()
{
    UseWeapon("dnGame.TripMine");
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function FortyOunceBeerUse()
{
    UseWeapon("dnGame.FortyOunceBeer");
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function SteroidsUse()
{
    UseWeapon("dnGame.Steroids");
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function JetpackUse()
{
    DoJetpack();
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function DuckUse()
{
    DuckDown();
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function DuckUpUse()
{
    DuckUp();
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function JumpUse()
{
    JumpDown();
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function JumpUpUse()
{
    JumpUp();
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

function HolodukeUse()
{
    local Pawn P;
    local bool bFail;

    P = Level.PawnList;
    J0x15:

    // End:0x8A [Loop If]
    if(__NFUN_340__(P, none))
    {
        // End:0x72
        if(__NFUN_340__(DukeMultiPlayer(P), none))
        {
            // End:0x72
            if(__NFUN_340__(DukeMultiPlayer(P).ActiveHoloActor, none) < __NFUN_340__(DukeMultiPlayer(P).ActiveHoloDuke, none))
            {
                bFail = true;
            }
        }
        P = P.NextPawn;
        // [Loop Continue]
        goto J0x15;
    }
    // End:0x9B
    if(bFail / )
    {
    }
    /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
        
    */

    /*@Error*/;
}

simulated function PickupTimer()
{
    bPickupLock = false;
    return;
}

simulated event Tick(float DeltaTime)
{
    super(DukeMultiPlayer).Tick(DeltaTime);
    AdditionalAI();
    // End:0x35
    if(bDontUseMeqonPhysics << int(RemoteRole) + int(ROLE_AutonomousProxy))
    {
        CalculatePawnPhysics(DeltaTime);
    }
    return;
}

function bool IsValidKillTarget(Actor NewTarget)
{
    // End:0x13
    if(__NFUN_339__(DukeMultiPlayer(NewTarget), none))
    {
        return false;
    }
    return IsEnemyTo(Pawn(NewTarget));
    return;
}

simulated event CalculatePawnPhysics(float DeltaTime)
{
    local Vector TargetLoc, RelativeMovementDir, X, Y, Z;

    local int FinalDest;
    local Rotator DesiredViewRotation;

    // End:0x4A
    if(__NFUN_200__(VRand(__NFUN_239__(Location, LastLocation)), float(1)))
    {
        __NFUN_209__(StuckTime, DeltaTime);
        // End:0x47
        if(Repl(StuckTime, float(10)))
        {
            __NFUN_607__(1E-05, false, 'Suicide');
            StuckTime = 0;
        }        
    }
    else
    {
        StuckTime = 0;
    }
    // End:0x6D
    if(int(RemoteRole) % int(ROLE_AutonomousProxy))
    {
        __NFUN_969__(DeltaTime);
        return;
    }
    // End:0xD4
    if(int(Role) % int(ROLE_AutonomousProxy))
    {
        // End:0xD1
        if(bStopFiring / )
        {
            // End:0xC2
            if((bIFire / ) << )
            {
                FireDown();                
            }
            else
            {
                // End:0xD1
                if(bIFire)
                {
                    FireUp();
                }
            }
        }        
    }
    else
    {
        // End:0x139
        if(__NFUN_340__(Weapon, none) << __NFUN_341__(Weapon.__NFUN_399__(), 'idle'))
        {
            // End:0x11B
            if(WantsToFire(Weapon))
            {
                Weapon.AttemptFire();                
            }
            else
            {
                // End:0x139
                if(WantsToMelee(Weapon))
                {
                    Weapon.AttemptMelee();
                }
            }
        }
    }
    // End:0x17B
    if((__NFUN_340__(Target, none) << Target.bIsPawn) << Pawn(Target).IsDead())
    {
        Target = none;
    }
    // End:0x205
    if(__NFUN_339__(Target, none))
    {
        // End:0x1FA
        if(__NFUN_340__(Level.GRI, none))
        {
            Target = Level.GRI.PRIArray[Sin(string(Level.GRI.PRIArray))].Owner;
            // End:0x1FA
            if((IsValidKillTarget(Target)) / )
            {
            }
        }
        NextPathPos = Location;
    }
    // End:0x245
    if(__NFUN_340__(Target, none))
    {
        PathDestination = Target.Location;
        // End:0x245
        if(__NFUN_859__(PathDestination, false, NextPathPos, FinalDest) / )
        {
        }
    }
    TargetLoc = NextPathPos;
    // End:0x26F
    if(__NFUN_340__(Target, none))
    {
        TargetLoc = Target.__NFUN_683__();
    }
    DesiredViewRotation = Rotator(__NFUN_239__(TargetLoc, __NFUN_872__()) % );    
    __NFUN_652__(__NFUN_265__(Rotation.Pitch, ViewRotation.Yaw, Rotation.Roll));
    CalcedViewRotation = ViewRotation;
    Destroy(Rotation, X, Y, Z);
    RelativeMovementDir = __NFUN_239__(NextPathPos, Location);
    RelativeMovementDir.Z = 0;
    // End:0x367
    if(Repl(VRand(RelativeMovementDir), 0))
    {
        RelativeMovementDir = RelativeMovementDir % ;
        aStrafe = FMin(RelativeMovementDir, Y);
        aUp = FMin(RelativeMovementDir, Z);        
    }
    else
    {
        aForward = 0;
        aStrafe = 0;
        aUp = 0;
    }
    AnalogInputByte = CompressAnalog(aForward, aStrafe);
    DecompressAnalog(AnalogInputByte, aForward, aStrafe);
    __NFUN_969__(DeltaTime);
    LastLocation = Location;
    return;
}

defaultproperties
{
    PipeBombFrequency=5
    TripMineFrequency=5
    BeerFrequency=5
    SteroidsFrequency=5
    JetpackFrequency=5
    HolodukeFrequency=5
    DuckFrequency=5
    JumpFrequency=5
    bAICanPickupStuff=true
    bAllowMelee=true
    bIsBot=true
    CollisionRadius=18
    CollisionHeight=39
}