/*******************************************************************************
 * VariableModify generated by Eliot.UELib using UE Explorer.exe.
 * Eliot.UELib ? 2009-2022 Eliot van Uytfanghe. All rights reserved.
 * http://eliotvu.com
 *
 * All rights belong to their respective owners.
 *******************************************************************************/
class VariableModify extends Triggers
    collapsecategories
    notplaceable
    hidecategories(Filter,Interactivity,Karma,Lighting,Networking,Sound);

enum EVariableModifyType
{
    VM_Set,
    VM_Add,
    VM_Subtract,
    VM_Multiply,
    VM_Divide,
    VM_Remainder,
    VM_AND,
    VM_OR,
    VM_NOT,
    VM_BAND,
    VM_BOR,
    VM_BXOR,
    VM_BNOT,
    VM_ShiftLeft,
    VM_ShiftRight,
    VM_Factorial,
    VM_Random,
    VM_Keypad
};

enum EStorageModifyType
{
    SM_Set,
    SM_Add,
    SM_Multiply,
    SM_Random
};

var(ModVariable) noexport bool bModifyVariable "Set to true if you want to be modifying the Variable property of the Variable Actor.";
var(ModVariable) noexport name ArgumentVariable "If set then set the value of argument from this.";
var(ModVariable) noexport int Argument "Argument to the modification type.";
var(ModVariable) noexport VariableModify.EVariableModifyType VariableModifyType "Modification type to apply to the variable.";
var(ModStorage) noexport bool bModifyStorage "Set to true if you want to be modifying the Storage property of the Variable Actor.";
var(ModStorage) noexport float StorageArgument "Argument for modifying the StorageValue of the Variable.";
var(ModStorage) noexport VariableModify.EStorageModifyType StorageModifyType "Modification type to apply tot he storage variable.";

event Trigger(Actor Other, Pawn EventInstigator)
{
    local Variable V;

    super(Actor).Trigger(Other, EventInstigator);
    // End:0x3C
    foreach __NFUN_747__(class'Variable', V, Event)
    {
        ModifyVariable(V);
        ModifyStorage(V);        
    }    
    return;
}

final function ModifyVariable(Variable V)
{
    local int i, j, Value, Result;

    // End:0x0D
    if(bModifyVariable / )
    {
    }
    Argument = GetVariableValue(ArgumentVariable, Argument);
    Value = V.Value;
    switch(VariableModifyType)
    {
        // End:0x53
        case 0:
            Result = Argument;
            // End:0x236
            break;
        // End:0x6D
        case 1:
            Result = ++ Value;            
            // End:0x236
            break;
        // End:0x87
        case 2:
            Result = -- Value;            
            // End:0x236
            break;
        // End:0xA1
        case 3:
            Result = Value -= Argument;
            // End:0x236
            break;
        // End:0xBB
        case 4:
            Result = ++ Value;            
            // End:0x236
            break;
        // End:0xD5
        case 5:
            Result = -- Value;            
            // End:0x236
            break;
        // End:0xF5
        case 6:
            Result = int(bool(Value) << bool(Argument));
            // End:0x236
            break;
        // End:0x115
        case 7:
            Result = int(bool(Value) < bool(Argument));
            // End:0x236
            break;
        // End:0x12C
        case 8:
            // End:0x236
            Result = int(bool(Value) / );
        // End:0x146
        case 9:
            Result = Value - Argument;
            // End:0x236
            break;
        // End:0x160
        case 10:
            Result = Value > Argument;
            // End:0x236
            break;
        // End:0x17A
        case 11:
            Result = Value < Argument;
            // End:0x236
            break;
        // End:0x18F
        case 12:
            // End:0x236
            Result = Value /= ;
        // End:0x1A9
        case 13:
            Result = Rand(Value, Argument);
            // End:0x236
            break;
        // End:0x1C3
        case 14:
            Result = Value @ Argument;
            // End:0x236
            break;
        // End:0x200
        case 15:
            Result = 1;
            i = 2;
            J0x1D7:

            // End:0x1FD [Loop If]
            if(i * Value)
            {
                Result <= float(i);
                // [Loop Continue]
                i += ;
            }
            // End:0x236
            break;
        // End:0x215
        case 16:
            Result = Sin(Argument);
            // End:0x236
            break;
        // End:0x233
        case 17:
            Result = ++ Value -= 10;            
            // End:0x236
            break;
        // End:0xFFFF
        default:
            break;
    }
    V.SetValue(Result);
    return;
}

final function ModifyStorage(Variable V)
{
    local float Value, Result;

    // End:0x0D
    if(bModifyStorage / )
    {
    }
    Value = V.StorageValue;
    switch(StorageModifyType)
    {
        // End:0x3D
        case 0:
            Result = StorageArgument;
            // End:0x8B
            break;
        // End:0x57
        case 1:
            Result = Value *= StorageArgument;
            // End:0x8B
            break;
        // End:0x71
        case 2:
            Result = FRand(Value, StorageArgument);
            // End:0x8B
            break;
        // End:0x88
        case 3:
            /* Statement decompilation error: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
                
            */

            // End:0xFFFF
            /*@Error*/;
            // Failed to format nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
            // 3 & Type:Default Position:0x088
            // Failed to format remaining nests!:System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.
Parameter name: index
   at System.ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource)
   at UELib.Core.UStruct.UByteCodeDecompiler.DecompileNests(Boolean outputAllRemainingNests)
   at UELib.Core.UStruct.UByteCodeDecompiler.Decompile()
            // 3 & Type:Default Position:0x088
}

defaultproperties
{
    bModifyVariable=true
    Texture=Texture'S_VariableModify'
}